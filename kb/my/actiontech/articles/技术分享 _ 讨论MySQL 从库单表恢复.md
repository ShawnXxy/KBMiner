# 技术分享 | 讨论：MySQL 从库单表恢复

**原文链接**: https://opensource.actionsky.com/20200914-mysql/
**分类**: MySQL 新特性
**发布时间**: 2020-09-14T01:03:45-08:00

---

作者：胡呈清
爱可生 DBA 团队成员，擅长故障分析、性能优化，个人博客：https://www.jianshu.com/u/a95ec11f67a8，欢迎讨论。
本文来源：原创投稿
*爱可生开源社区出品，原创内容未经授权不得随意使用，转载请联系小编并注明来源。
如果从库上表 t 数据与主库不一致，导致复制错误，整个库的数据量很大，重做从库很慢，如何单独恢复这张表的数据？通常认为是不能修复单表数据的，因为涉及到各表状态不一致的问题。下面就列举备份单表恢复到从库会面临的问题以及解决办法：
##### 场景 1
如果复制报错后，没有使用跳过错误、复制过滤等方法修复主从复制。主库数据一直在更新，从库数据停滞在报错状态（假设 GTID 为 aaaa:1-100）。
修复步骤：
- 在主库上备份表 t （假设备份快照 GTID 为 aaaa:1-10000）；
- 恢复到从库；
- 启动复制。
这里的问题是复制起始位点是 aaaa:101，从库上表 t 的数据状态是领先其他表的。aaaa:101-10000 这些事务中只要有修改表 t 数据的事务，就会导致复制报错 ，比如主键冲突、记录不存在（而 aaaa:101 这个之前复制报错的事务必定是修改表 t 的事务）
**解决办法：启动复制时跳过 aaaa:101-10000 这些事务中修改表 t 的事务。**
正确的修复步骤：
1. 在主库上备份表 t （假设备份快照 GTID 为 aaaa:1-10000），恢复到从库；
2. 设置复制过滤，过滤表 t：- 
`CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE = ('db_name.t');`
3. 启动复制，回放到 aaaa:10000 时停止复制（此时从库上所有表的数据都在同一状态，是一致的）;- 
```
START SLAVE UNTIL SQL_AFTER_GTIDS = 'aaaa:10000';
```
4. 删除复制过滤，正常启动复制。注意事项：这里要用 mysqldump &#8211;single-transaction &#8211;master-data=2，记录备份快照对应的 GTID
##### 场景 2
如果复制报错后，使用跳过错误、复制过滤等办法修复了主从复制。主、从库数据一直在更新。
修复步骤：
- 在主库上备份表 t （假设备份快照 GTID为 aaaa:1-10000）；
- 停止从库复制，GTID为 aaaa:1-20000；
- 恢复表 t 到从库；
- 启动复制。
这里的问题是复制起始位点是 aaaa:20001，aaaa:10000-20000 这些事务将不会在从库上回放，如果这里面有修改表 t 数据的事务，从库上将丢失这部分数据。
**解决办法：从备份开始到启动复制，锁定表 t，保证 aaaa:10000-20000 中没有修改表 t 的事务。**
正确修复步骤：
- 对表 t 加读锁；
- 在主库上备份表 t；
- 停止从库复制，恢复表 t；
- 启动复制；
- 解锁表 t。
如果是大表，这里可以用可传输表空间方式备份、恢复表，减少锁表时间。
相关推荐：
[技术分享 | MySQL 子查询优化](https://opensource.actionsky.com/20200628-mysql/)
[技术分享 | MySQL 优化：JOIN 优化实践](https://opensource.actionsky.com/20200121-mysql/)